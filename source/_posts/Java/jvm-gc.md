---
title: GC（Gabage Collection）
description: '待定'
tags:
  - java
categories:
  - java
date: 2022-01-04 23:09:00
---

## 为什么要有GC

内存资源是有限的

## 基本原理-标记清除算法

![image-20220105210350723](jvm-gc/image-20220105210350723.png)

* Marking（标记）: 遍历所有的可达对象，并在本地内存(native)中分门别类记下。 

* Sweeping（清除）: 这一步保证了，不可达对象 所占用的内存，在之后进行内存分配时可以重用。 

  并行 GC 和 CMS 的基本原理。 

  优势：可以处理循环依赖，只扫描部分对象 

  除了清除，还要做压缩。 怎么才能标记和清除清楚上百万对象呢？ 答案就是 **STW**，让全世界停止下来。

## 分代

![image-20220105210656637](jvm-gc/image-20220105210656637.png)

分代假设：大部分新生对象很快无用； 存活较长时间的对象，可能存活更长时间

![image-20220105210755810](jvm-gc/image-20220105210755810.png)

不同类型对象不同区域，不同策略处理。

* 对象分配在新生代的 Eden 区， 标记阶段 Eden 区存活的对象就会复制到存活区； 两个存活区 from 和 to，互换角色。对象存活到一定周期会提升到老年代
* 老年代默认都是存活对象，采用移动方式：
  1. 标记所有通过 GC roots 可达的对象；
  2. 删除所有不可达对象；
  3. 整理老年代空间中的内容，方法是将所有的存活对象复制，从老年代空间开始的地方依次存放

## 可以作为 GC Roots 的对象

* 当前正在执行的方法里的局部变量和 输入参数 
* 活动线程（Active threads） 
* 所有类的静态字段（static field） 
* JNI 引用

