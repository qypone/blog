---
title: GC（Gabage Collection）
description: '常见GC，串行GC、并行GC、CMS、G1、ZGC等'
tags:
  - java
categories:
  - java
abbrlink: bffdd010
date: 2022-01-10 11:00:00
---

## 串行 GC（Serial GC）

```sh
-XX：+UseSerialGC 配置串行 GC
```

### 介绍

串行 GC 对年轻代使用 mark-copy（标记-复制） 算法，对老年代使用 mark-sweep-compact （标记-清除-整理）算法

两者都是单线程的垃圾收集器，不能进行并行处理，所以都会触发全线暂停（**STW**），停止所有的应用线程

因此这种 GC 算法不能充分利用多核 CPU。不管有多少CPU 内核，JVM 在垃圾收集时都只能使用单个核心

### 特点

CPU 利用率高，暂停时间长。简单粗暴，就像老式的电脑，动不动就卡死

### 适用场景

该选项只适合几百 MB 堆内存的 JVM，而且是单核 CPU 时比较有用

## 并行 GC（Parallel GC）

```sh
-XX：+UseParallelGC
-XX：+UseParallelOldGC
-XX：+UseParallelGC -XX:+UseParallelOldGC
-XX：ParallelGCThreads=N //来指定 GC 线程数， 其默认值为 CPU 核心数
```

年轻代和老年代的垃圾回收都会触发 STW 事件

在年轻代使用 标记-复制（mark-copy）算法，在老年代使用 标记-清除-整理（mark-sweepcompact）算法

### 适用场景

并行垃圾收集器适用于多核服务器，主要目标是增加吞吐量。因为对系统资源的有效使用，能达到更高的吞吐量:

* 在 GC 期间，所有 CPU 内核都在并行清理垃圾，所以总暂停时间更短；

* 在两次 GC 周期的间隔期，没有 GC 线程在运行，不会消耗任何系统资源

## CMS

```sh
-XX：+UseConcMarkSweepGC
```

其对年轻代采用并行 STW 方式的 mark-copy (标记-复制)算法，对老年代主要使用并发 marksweep (标记-清除)算法

CMS GC 的设计目标是避免在老年代垃圾收集时出现长时间的卡顿，主要通过两种手段来达成此 目标

1. 不对老年代进行整理，而是使用空闲列表（free-lists）来管理内存空间的回收

2. 在 mark-and-sweep （标记-清除） 阶段的大部分工作和应用线程一起并发执行

也就是说，在这些阶段并没有明显的应用线程暂停。但值得注意的是，它仍然和应用线程争抢 CPU 时间。默认情况下，CMS 使用的并发线程数等于 CPU 核心数的 1/4。

### 适用场景

如果服务器是多核 CPU，并且主要调优目标是降低 GC 停顿导致的系统延迟，那么使用 CMS 是 个很明智的选择。进行老年代的并发回收时，可能会伴随着多次年轻代的 minor GC。

### 6个阶段

* 阶段 1: Initial Mark（初始标记）

* 阶段 2: Concurrent Mark（并发标记）

* 阶段 3: Concurrent Preclean（并发预清理） 

* 阶段 4: Final Remark（最终标记） 

* 阶段 5: Concurrent Sweep（并发清除） 

* 阶段 6: Concurrent Reset（并发重置）

![image-20220110161939957](jvm-gc2/image-20220110161939957.png)

这个阶段伴随着 STW 暂停。初始标记的目标是标记所有的根对象，包括根对象直接引用的对象，以及被年轻代中 所有存活对象所引用的对象（老年代单独回收）

![image-20220110162405481](jvm-gc2/image-20220110162405481.png)

在此阶段，CMS GC遍历老年代，标记所有的存活对象，从前一阶段 “Initial Mark” 找到的根对象开始算起。 “并发标记”阶段，就是与应用程序同时运行，不用暂停的阶段

![image-20220110163003864](jvm-gc2/image-20220110163003864.png)

此阶段同样是与应用线程并发执行的，不需要停止应用线 程。 因为前一阶段【并发标记】与程序并发运行，可能 有一些引用关系已经发生了改变。如果在并发标记过程中 引用关系发生了变化，JVM 会通过“Card（卡片）”的方 式将发生了改变的区域标记为“脏”区，这就是所谓的 卡片 标记（Card Marking）。

![image-20220110165315816](jvm-gc2/image-20220110165315816.png)

最终标记阶段是此次 GC 事件中的第二次（也是最后一 次）STW 停顿。本阶段的目标是完成老年代中所有存活 对象的标记. 因为之前的预清理阶段是并发执行的，有可 能 GC 线程跟不上应用程序的修改速度。所以需要一次 STW 暂停来处理各种复杂的情况。 通常 CMS 会尝试在年轻代尽可能空的情况下执行 Final Remark 阶段，以免连续触发多次 STW 事件

![image-20220110165342090](jvm-gc2/image-20220110165342090.png)

此阶段与应用程序并发执行，不需要 STW 停顿。JVM 在此 阶段删除不再使用的对象，并回收他们占用的内存空间

阶段 6

Concurrent Reset（并发重置） 此阶段与应用程序并发执行，重置 CMS 算法相关的内部 数据，为下一次 GC 循环做准备

### 被废弃

在 JDK 9 中被废弃了。根据 JEP-291中的说明，为了减轻 GC 代码的维护负担以及加速新功能开发，决定在 JDK9 中废弃CMS GC

## G1



## ZGC

